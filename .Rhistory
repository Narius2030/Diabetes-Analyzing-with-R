labels = c("Underweight", "Normal", "Overweight", "Obese"))
ggplot(diabetes, aes(x = BMI_Category)) +
geom_bar(stat = "count") +
labs(title = "Distribution of BMI Categories", x = "BMI Category", y = "Count") +
theme_bw()
diabetes$BMI_Category<- as.factor(diabetes$BMI_Category)
str(diabetes)
num_diabetes <- diabetes
num_diabetes$BMI_Category <- cut(num_diabetes$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c(0, 1, 2, 3))
num_diabetes$BMI_Category <- as.integer(num_diabetes$BMI_Category)
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(num_diabetes),2)
# reduce the size of correlation matrix
melted_corr_mat <- melt(corr_mat)
# head(melted_corr_mat)
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + geom_tile() +
geom_text(aes(Var2, Var1, label = value), color = "white", size = 4)
set.seed(123)
samp <- sample(nrow(diabetes), 0.8 * nrow(diabetes))
train <- diabetes[samp, ]
test <- diabetes[-samp, ]
dim(test)
library(randomForest)
model <- randomForest(BMI_Category ~ . - Outcome, data = train, ntree = 1000, mtry = 3)
model
prediction <- predict(model, newdata = test)
table(prediction, test$BMI_Category)
prediction
sum(prediction==test$BMI_Category) / nrow(test) # The output is as shown below
# Đọc file CSV trực tiếp từ đường link
diabetes <- read_csv("https://drive.google.com/uc?id=15mjrv0LV2T6GWNdAuW-QhXVdtMkQALlh")
# Hiển thị dữ liệu
diabetes
na_count<-colSums(sapply(diabetes,is.na))
na_count
diabetes_median <- diabetes %>%
mutate_all(~ ifelse(is.na(.), median(., na.rm = TRUE), .))
diabetes_mean <- diabetes %>%
mutate_all(~ ifelse(is.na(.), mean(., na.rm = TRUE), .))
fill_mode <- function(x) {
mode_val <- names(sort(table(x), decreasing = TRUE))[1]
x[is.na(x)] <- mode_val
return(x)
}
diabetes_mode <- diabetes %>%
mutate_all(fill_mode)
diabetes_z <- (diabetes - colMeans(diabetes)) / apply(diabetes, 2, sd)
diabetes_z
melted_diabetes <- gather(diabetes_z, key = "Variable", value = "Z-score")
# Vẽ scatter plot cho tất cả các cột
ggplot(melted_diabetes, aes(x = Variable, y = `Z-score`, color = `Z-score`)) +
geom_point() +
labs(x = "Variable", y = "Z-score", title = "Scatter Plots of Z-scores") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Điều chỉnh góc và vị trí của chú thích trên trục x
# Lọc các giá trị Z-score mà tất cả đều nhỏ hơn 360
diabetes_filter <- diabetes[rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z), ]
# Hiển thị kích thước của bộ dữ liệu sau khi loại bỏ
cat("Còn lại số lượng hàng và cột là:", dim(diabetes_filter))
attach(diabetes)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes$BMI_Category <- cut(diabetes$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c("Underweight", "Normal", "Overweight", "Obese"))
ggplot(diabetes, aes(x = BMI_Category)) +
geom_bar(stat = "count") +
labs(title = "Distribution of BMI Categories", x = "BMI Category", y = "Count") +
theme_bw()
diabetes$BMI_Category<- as.factor(diabetes$BMI_Category)
str(diabetes)
diabetes_filter$BMI_Category <- cut(diabetes_filter$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c("Underweight", "Normal", "Overweight", "Obese"))
ggplot(diabetes_filter, aes(x = BMI_Category)) +
geom_bar(stat = "count") +
labs(title = "Distribution of BMI Categories", x = "BMI Category", y = "Count") +
theme_bw()
diabetes_filter$BMI_Category<- as.factor(diabetes_filter$BMI_Category)
str(diabetes_filter)
num_diabetes <- diabetes_filter
num_diabetes$BMI_Category <- cut(num_diabetes$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c(0, 1, 2, 3))
num_diabetes$BMI_Category <- as.integer(num_diabetes$BMI_Category)
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(num_diabetes),2)
# reduce the size of correlation matrix
melted_corr_mat <- melt(corr_mat)
# head(melted_corr_mat)
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + geom_tile() +
geom_text(aes(Var2, Var1, label = value), color = "white", size = 4)
set.seed(123)
samp <- sample(nrow(diabetes_filter), 0.8 * nrow(diabetes_filter))
train <- diabetes_filter[samp, ]
test <- diabetes_filter[-samp, ]
dim(test)
library(randomForest)
model <- randomForest(BMI_Category ~ . - Outcome, data = train, ntree = 1000, mtry = 3)
model
prediction <- predict(model, newdata = test)
table(prediction, test$BMI_Category)
prediction
sum(prediction==test$BMI_Category) / nrow(test) # The output is as shown below
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(cowplot)
library(gridExtra)
pie_outlier <- function(outlier_col) {for (col in outlier_col) {
rates <- calculate_rate(unlist(diabetes[, col]))
pie_data <- data.frame(
type = c("Outliers", "Regular"),
rate = c(rates$outlier, rates$regular)
)
# Vẽ trực quan những cột có tỉ lệ ngoại lai >= 2.3%
return(ggplot(pie_data, aes(x="", y = rate, fill=type)) +
geom_bar(stat="identity", width=1, color="white") +
coord_polar("y", start=0) +
theme_void() +
labs(title = paste("Outlier Rate vs Regular Value Rate in", col),
caption = paste0("Total Outliers (%):", round(rates$outlier, 2), ", Regular Values (%):", round(rates$regular, 2))))
}}
gird.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=2)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=2)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=3)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=3)
pie_outlier <- function(outlier_col) {for (col in outlier_col) {
rates <- calculate_rate(unlist(diabetes[, col]))
pie_data <- data.frame(
type = c("Outliers", "Regular"),
rate = c(rates$outlier, rates$regular)
)
# Vẽ trực quan những cột có tỉ lệ ngoại lai >= 2.3%
return(ggplot(pie_data, aes(x="", y = rate, fill=type)) +
geom_bar(stat="identity", width=1, color="white") +
coord_polar("y", start=0) +
theme_void() +
labs(title = paste(col),
caption = paste0("Total Outliers (%):", round(rates$outlier, 2), ", Regular Values (%):", round(rates$regular, 2))))
}}
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=3)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=2)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol=2,
top = c(0.5, 0.5),
left = c(0.2, 0.2),
bottom = c(0.5, 0.5),
right = c(0.2, 0.2))
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol=2,
top = c(0.5, 0.5),
left = c(0.2, 0.2),
bottom = c(0.7, 0.7),
right = c(0.2, 0.2))
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol=2,
top = c(0.5, 0.5),
left = c(0.2, 0.2),
bottom = c(2, 2),
right = c(0.2, 0.2))
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol=2,
top = c(0.5, 0.5),
left = c(1, 1),
bottom = c(2, 2),
right = c(0.2, 0.2))
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol=2,
top = c(0.5, 0.5),
left = c(1, 0.2),
bottom = c(2, 2),
right = c(0.2, 0.2))
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol=2,
space=0.75)
plot_grid(
pie_outlier("BloodPressure"), pie_outlier("Insulin"),
pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"),
ncol = 2,
spacer = "grid"
)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"), pie_outlier("DiabetesPedigreeFunction"), ncol=2)
library(reader)
diabetes <- read.csv('diabetes.csv')
diabetes
str(diabetes)
summary(diabetes)
library(ggplot2)
# Boxplot cho Age
boxplot(diabetes$Age,
col="#ff0066",
main="Boxplot for Descriptive Analysis of Age")
# Boxplot cho Pregnancies
boxplot(diabetes$Pregnancies,
col="yellow",
main="Boxplot for Descriptive Analysis of Pregnancy")
# Boxplot cho Outcome và Glucose theo người mắc bệnh và không
diabetes_groups <- cut(diabetes$Outcome, c(-Inf, 0, Inf), labels = c("Không bệnh", "Bệnh"))
ggplot(data = diabetes, aes(x = diabetes_groups, y = Glucose)) +
geom_boxplot(fill = c("lightblue", "green")) +
labs(x = "Outcome", y = "Glucose (mg/dL)")
ggplot(data=diabetes, aes(x=Insulin, y=Glucose, group=1)) +
geom_line(color="red")
plot(density(diabetes$Glucose),
col="yellow",
main="Density Plot for Glucose",
xlab="Glucose",
ylab="Density")
polygon(density(diabetes$Glucose),
col="#ccff66")
ggplot(data = diabetes, aes(x = Glucose, y = Outcome)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Mối quan hệ giữa nồng độ glucose và kết quả bệnh tiểu đường",
x = "Nồng độ glucose (mg/dL)",
y = "Kết quả (1 = mắc bệnh, 0 = không mắc bệnh)")
ggplot(data = diabetes, aes(x = SkinThickness, y = Outcome)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Mối quan hệ giữa độ dày của da và kết quả bệnh tiểu đường",
x = "độ dày da (mm)",
y = "Kết quả (1 = mắc bệnh, 0 = không mắc bệnh)")
ggplot(data = diabetes, aes(x = Pregnancies, y = Outcome)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Mối quan hệ giữa số lần mang thai và kết quả bệnh tiểu đường",
x = "Số lần mang thai (lần)",
y = "Kết quả (1 = mắc bệnh, 0 = không mắc bệnh)")
sum_of_nan <- sum(is.na(diabetes))
paste("Tổng số giá trị rỗng trong dataset:", sum_of_nan)
for (col in colnames(diabetes)) {
nan_of_col <- sum(is.na(diabetes[, col]))
print(paste("Số giá trị rỗng trong cột", col, ":", nan_of_col))
}
find_outliers <- function(inp, na.rm = TRUE) {
i.qnt <- quantile(inp, probs = c(0.25, 0.75), na.rm = na.rm)
i.max <- 1.5 * IQR(inp, na.rm = na.rm)
outliers <- inp < (i.qnt[1] - i.max) | inp > (i.qnt[2] + i.max)
return(outliers)
}
calculate_rate <- function(inp) {
num_outliers <- sum(find_outliers(inp))
num_regular <- length(inp) - num_outliers
outlier_rate <- num_outliers / length(inp) * 100
regular_rate <- num_regular / length(inp) * 100
rates <- list(outlier=outlier_rate, regular=regular_rate)
return (rates)
}
for (col in colnames(diabetes)) {
rates <- calculate_rate(diabetes[, col])
# Liệt kê tỉ lệ giá trị ngoại lại trong từng cột
print(paste(col, "-", "Total Outliers (%):", round(rates$outlier, 2), ", Regular Values (%):", round(rates$outlier, 2)))
}
pie_outlier <- function(outlier_col) {for (col in outlier_col) {
rates <- calculate_rate(unlist(diabetes[, col]))
pie_data <- data.frame(
type = c("Outliers", "Regular"),
rate = c(rates$outlier, rates$regular)
)
# Vẽ trực quan những cột có tỉ lệ ngoại lai >= 2.3%
return(ggplot(pie_data, aes(x="", y = rate, fill=type)) +
geom_bar(stat="identity", width=1, color="white") +
coord_polar("y", start=0) +
theme_void() +
labs(title = paste(col),
caption = paste0("Total Outliers (%):", round(rates$outlier, 2), ", Regular Values (%):", round(rates$regular, 2))))
}}
library(gridExtra)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"),pie_outlier("DiabetesPedigreeFunction"), ncol=2)
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(diabetes),2)
# reduce the size of correlation matrix
melted_corr_mat <- melt(corr_mat)
# head(melted_corr_mat)
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + geom_tile() +
geom_text(aes(Var2, Var1, label = value), color = "white", size = 4)
library(reader)
diabetes <- read.csv('diabetes.csv')
diabetes
str(diabetes)
summary(diabetes)
library(ggplot2)
par(mfrow=c(1,3))
# Boxplot cho Age
boxplot(diabetes$Age,
col="#ff0066",
main="Boxplot for Descriptive Analysis of Age")
# Boxplot cho Pregnancies
boxplot(diabetes$Pregnancies,
col="yellow",
main="Boxplot for Descriptive Analysis of Pregnancy")
# Boxplot cho Outcome và Glucose theo người mắc bệnh và không
diabetes_groups <- cut(diabetes$Outcome, c(-Inf, 0, Inf), labels = c("Không bệnh", "Bệnh"))
boxplot(diabetes$Glucose~diabetes_groups, xlab="Outcome", ylab="Glucose (mg/dl)", main="Tỉ lệ giữa Glucose và Outcome ở hai đối tượng", col="pink")
box(which = "outer", lty = "solid")
par(mfrow=c(1,2))
plot(Insulin, Glucose, type='p', col=c("red"), pch=20, main="Scatter Plot for Glucose and Insulin")
par(mfrow=c(1,2))
plot(diabetes$Insulin, diabetes$Glucose, type='p', col=c("red"), pch=20, main="Scatter Plot for Glucose and Insulin")
plot(density(diabetes$Glucose),
col="yellow",
main="Density Plot for Glucose",
xlab="Glucose",
ylab="Density")
polygon(density(diabetes$Glucose),
col="#ccff66")
box(which="outer", lty="solid")
p1 <- ggplot(data = diabetes, aes(x = Glucose, y = Outcome)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Mối quan hệ giữa nồng độ glucose và kết quả bệnh tiểu đường",
x = "Nồng độ glucose (mg/dL)",
y = "Kết quả (1 = mắc bệnh, 0 = không mắc bệnh)")
p2 <- ggplot(data = diabetes, aes(x = SkinThickness, y = Outcome)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Mối quan hệ giữa độ dày của da và kết quả bệnh tiểu đường",
x = "độ dày da (mm)",
y = "Kết quả (1 = mắc bệnh, 0 = không mắc bệnh)")
p3 <- ggplot(data = diabetes, aes(x = Pregnancies, y = Outcome)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Mối quan hệ giữa số lần mang thai và kết quả bệnh tiểu đường",
x = "Số lần mang thai (lần)",
y = "Kết quả (1 = mắc bệnh, 0 = không mắc bệnh)")
grid.arrange(p1, p2, p3, ncol = 3)
sum_of_nan <- sum(is.na(diabetes))
paste("Tổng số giá trị rỗng trong dataset:", sum_of_nan)
for (col in colnames(diabetes)) {
nan_of_col <- sum(is.na(diabetes[, col]))
print(paste("Số giá trị rỗng trong cột", col, ":", nan_of_col))
}
find_outliers <- function(inp, na.rm = TRUE) {
i.qnt <- quantile(inp, probs = c(0.25, 0.75), na.rm = na.rm)
i.max <- 1.5 * IQR(inp, na.rm = na.rm)
outliers <- inp < (i.qnt[1] - i.max) | inp > (i.qnt[2] + i.max)
return(outliers)
}
calculate_rate <- function(inp) {
num_outliers <- sum(find_outliers(inp))
num_regular <- length(inp) - num_outliers
outlier_rate <- num_outliers / length(inp) * 100
regular_rate <- num_regular / length(inp) * 100
rates <- list(outlier=outlier_rate, regular=regular_rate)
return (rates)
}
for (col in colnames(diabetes)) {
rates <- calculate_rate(diabetes[, col])
# Liệt kê tỉ lệ giá trị ngoại lại trong từng cột
print(paste(col, "-", "Total Outliers (%):", round(rates$outlier, 2), ", Regular Values (%):", round(rates$outlier, 2)))
}
pie_outlier <- function(outlier_col) {for (col in outlier_col) {
rates <- calculate_rate(unlist(diabetes[, col]))
pie_data <- data.frame(
type = c("Outliers", "Regular"),
rate = c(rates$outlier, rates$regular)
)
# Vẽ trực quan những cột có tỉ lệ ngoại lai >= 2.3%
return(ggplot(pie_data, aes(x="", y = rate, fill=type)) +
geom_bar(stat="identity", width=1, color="white") +
coord_polar("y", start=0) +
theme_void() +
labs(title = paste(col),
caption = paste0("Total Outliers (%):", round(rates$outlier, 2), ", Regular Values (%):", round(rates$regular, 2))))
}}
library(gridExtra)
grid.arrange(pie_outlier("BloodPressure"), pie_outlier("Insulin"), pie_outlier("BMI"),pie_outlier("DiabetesPedigreeFunction"), ncol=2)
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(diabetes),2)
# reduce the size of correlation matrix
melted_corr_mat <- melt(corr_mat)
# head(melted_corr_mat)
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + geom_tile() +
geom_text(aes(Var2, Var1, label = value), color = "white", size = 4)
knitr::opts_chunk$set(echo = TRUE)
data <- read.csv('gdp_thuc_te_theo_quy.csv')
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t");
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t")
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t")
dataset
typeof(dataset$Q1.2015)
count <- 0
for (col in colnames(dataset)) {
if (count != 0) {
dataset[, col] <- as.numeric(dataset[, col])
}
count <- count + 1
}
str(dataset)
dataset
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t")
dataset
count <- 0
for (col in colnames(dataset)) {
print(col)
if (count != 0) {
dataset[, col] <- as.numeric(dataset[, col])
}
count <- count + 1
}
str(dataset)
count <- 0
for (col in colnames(dataset)) {
print(typeof(dataset[, col]))
if (count != 0) {
dataset[, col] <- as.numeric(dataset[, col])
}
count <- count + 1
}
str(dataset)
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t")
dataset
count <- 0
for (col in colnames(dataset)) {
if (count != 0) {
dataset[, col] <- as.numeric(gsub(",", "", dataset[, col]))
}
count <- count + 1
}
str(dataset)
xay_dung <- dataset[10, ]
dich_vu <- dataset[11, ]
t.test(xay_dung,dich_vu,var.equal=FALSE)
xay_dung <- df[10, 2:ncol(df)]
xay_dung <- dataset[10, 2:ncol(df)]
xay_dung <- dataset[10, 2:ncol(dataset)]
dich_vu <- dataset[11, 2:ncol(dataset)]
t.test(xay_dung,dich_vu,var.equal=FALSE)
xay_dung <- dataset[10, 2:ncol(dataset)]
dich_vu <- dataset[11, 2:ncol(dataset)]
xay_dung
xay_dung <- dataset[10, 2:ncol(dataset)]
dich_vu <- dataset[11, 2:ncol(dataset)]
xay_dung
dich_vu
for (row in row.names(dataset)) {
if (col != "Xây dựng") {
# Tạo dữ liệu
data <- data.frame(
year <- colnames(dataset),
qtr <- c("Q1", "Q2", "Q3"),
industry <- row.names,
growth <- dataset[row, ]
)
# Vẽ biểu đồ đường
ggplot(data, aes(x=year, y=growth, color=industry)) +
geom_line() +
labs(title="Tăng trưởng theo từng ngành", x="Năm", y="Tăng trưởng (%)")
}
}
library(ggplot2)
for (row in row.names(dataset)) {
if (col != "Xây dựng") {
# Tạo dữ liệu
data <- data.frame(
year <- colnames(dataset),
qtr <- c("Q1", "Q2", "Q3"),
industry <- row.names,
growth <- dataset[row, ]
)
# Vẽ biểu đồ đường
ggplot(data, aes(x=year, y=growth, color=industry)) +
geom_line() +
labs(title="Tăng trưởng theo từng ngành", x="Năm", y="Tăng trưởng (%)")
}
}
library(ggplot2)
for (col in colnames(dataset)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = dataset$X,
value = dataset[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
