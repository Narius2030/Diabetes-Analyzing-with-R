<<<<<<< HEAD
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# Tạo dữ liệu giả định
xay_dung <- dataset[10, 2:ncol(dataset)]
dich_vu <- dataset[11, 2:ncol(dataset)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t");
dataset
# Tạo dữ liệu giả định
xay_dung <- dataset[10, 2:ncol(dataset)]
dich_vu <- dataset[11, 2:ncol(dataset)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
#Chuyển kiểu dữ liệu sang kiểu số
num_columns <- ncol(dataset)
for (i in 2:ncol(dataset)) {
for (j in 1:nrow(dataset)) {
df[j, i] <- as.numeric(gsub(",", "", dataset[j, i]))
}
}
for (i in 2:ncol(dataset)) {
dataset[, i] <- as.numeric(dataset[, i])
}
str(datasetf)
dataset <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t");
dataset
#Chuyển kiểu dữ liệu sang kiểu số
num_columns <- ncol(dataset)
for (i in 2:ncol(dataset)) {
for (j in 1:nrow(dataset)) {
df[j, i] <- as.numeric(gsub(",", "", dataset[j, i]))
}
}
for (i in 2:ncol(dataset)) {
dataset[, i] <- as.numeric(dataset[, i])
}
str(dataset)
df <- read.csv('gdp_danh_nghia_theo_quy.csv', fileEncoding = "UTF-16LE", sep="\t");
df
#Chuyển kiểu dữ liệu sang kiểu số
num_columns <- ncol(df)
for (i in 2:ncol(df)) {
for (j in 1:nrow(df)) {
df[j, i] <- as.numeric(gsub(",", "", df[j, i]))
}
}
for (i in 2:ncol(df)) {
df[, i] <- as.numeric(df[, i])
}
str(df)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# In kết quả
print(result)
xay_dung <- df[10,2:ncol(df) ]
dich_vu <- df[11,2:ncol(df) ]
xay_dung <- df[10,2:ncol(df) ]
dich_vu <- df[11,2:ncol(df) ]
xay_dung <- df[10,2:ncol(df)]
dich_vu <- df[11,2:ncol(df) ]
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# In kết quả
print(result)
# Tạo dữ liệu giả định
xay_dung <- df[10, 2:ncol(df)]
dich_vu <- df[11, 2:ncol(df)]
# Thực hiện kiểm định t-test
result <- t.test(xay_dung, dich_vu)
# In kết quả
print(result)
for (col in colnames(dataset)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = dataset$X,
value = dataset[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = dataset$X,
value = dataset[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
library("readr")
library("ggplot")
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = dataset$X,
value = dataset[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
install.packages("readr")
install.packages("readr")
install.packages("ggplot")
install.packages("readr")
install.packages("ggplot")
library("readr")
library("ggplot")
library("readr")
library("ggplot2")
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = dataset$X,
value = dataset[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
library("readr")
library("ggplot2")
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = dataset$X,
value = dataset[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = df$X,
value = df[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = df$X,
value = df[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
for (col in colnames(df)) {
# Tạo dataframe mới từ cột hiện tại
data <- data.frame(
group = df$X,
value = df[, col]
)
# Vẽ biểu đồ cột và ẩn nhãn trên trục x
print(ggplot(data, aes(x = group, y = value, fill = group)) +
geom_col(width = 1, color = "white") +
theme_minimal() +
theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
ggtitle(paste("Distribution of", col)))
}
install.packages("readr")
=======
<<<<<<< HEAD
train <- diabetes_scale [1:530,]
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
>>>>>>> bf69e8bd96af1c7edcfcdf92883a59e0f2efff02
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
# Đọc file CSV trực tiếp từ đường link
diabetes <- read_csv("https://drive.google.com/uc?id=15mjrv0LV2T6GWNdAuW-QhXVdtMkQALlh")
# Hiển thị dữ liệu
diabetes
<<<<<<< HEAD
diabetes_z <- (diabetes - colMeans(diabetes)) / apply(diabetes, 2, sd)
diabetes_z
melted_diabetes <- gather(diabetes_z, key = "Variable", value = "Z-score")
# Vẽ scatter plot cho tất cả các cột
ggplot(melted_diabetes, aes(x = Variable, y = `Z-score`, color = `Z-score`)) +
geom_point() +
labs(x = "Variable", y = "Z-score", title = "Scatter Plots of Z-scores") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Điều chỉnh góc và vị trí của chú thích trên trục x
# Lọc các giá trị Z-score mà tất cả đều nhỏ hơn 360
diabetes_filter <- diabetes[rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z), ]
# Hiển thị kích thước của bộ dữ liệu sau khi loại bỏ
cat("Còn lại số lượng hàng và cột là:", dim(diabetes_filter))
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes_filter $BloodPressure <- NULL
diabetes_filter $SkinThickness <- NULL
min_max_scaler <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
diabetes_filter <- as.data.frame(lapply(diabetes_filter, min_max_scaler))
diabetes_filter
train <- diabetes_filter [1:530,]
test <- diabetes_filter [531:760,]
model <-glm(Outcome ~.,family=binomial(link='logit'),data=train)
summary(model)
anova(model, test="Chisq")
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z)
[rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z), ]
rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z)
(apply(diabetes_z, 2, function(x) abs(x) < 700))
rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.6,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.7,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.6,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.4,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.7,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
# Đọc file CSV trực tiếp từ đường link
diabetes <- read.csv("https://drive.google.com/uc?id=15mjrv0LV2T6GWNdAuW-QhXVdtMkQALlh")
# Hiển thị dữ liệu
diabetes
na_count<-colSums(sapply(diabetes,is.na))
na_count
=======
na_count<-colSums(sapply(diabetes,is.na))
na_count
diabetes_median <- diabetes %>%
mutate_all(~ ifelse(is.na(.), median(., na.rm = TRUE), .))
diabetes_mean <- diabetes %>%
mutate_all(~ ifelse(is.na(.), mean(., na.rm = TRUE), .))
fill_mode <- function(x) {
mode_val <- names(sort(table(x), decreasing = TRUE))[1]
x[is.na(x)] <- mode_val
return(x)
}
diabetes_mode <- diabetes %>%
mutate_all(fill_mode)
>>>>>>> bf69e8bd96af1c7edcfcdf92883a59e0f2efff02
diabetes_z <- (diabetes - colMeans(diabetes)) / apply(diabetes, 2, sd)
diabetes_z
melted_diabetes <- gather(diabetes_z, key = "Variable", value = "Z-score")
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
melted_diabetes <- gather(diabetes_z, key = "Variable", value = "Z-score")
# Vẽ scatter plot cho tất cả các cột
ggplot(melted_diabetes, aes(x = Variable, y = `Z-score`, color = `Z-score`)) +
geom_point() +
labs(x = "Variable", y = "Z-score", title = "Scatter Plots of Z-scores") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Điều chỉnh góc và vị trí của chú thích trên trục x
# Lọc các giá trị Z-score mà tất cả đều nhỏ hơn 700
diabetes_filter <- diabetes[rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z), ]
# Hiển thị kích thước của bộ dữ liệu sau khi loại bỏ
cat("Còn lại số lượng hàng và cột là:", dim(diabetes_filter))
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
=======
>>>>>>> 3de0a0e5fbe2938e07ea60d1c410ac0b0b394639
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes_f<-diabetes_filter
diabetes_f $BloodPressure <- NULL
diabetes_f $SkinThickness <- NULL
min_max_scaler <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
diabetes_scale <- as.data.frame(lapply(diabetes_f, min_max_scaler))
diabetes_scale
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
na_count<-colSums(sapply(diabetes,is.na))
na_count
diabetes_median <- diabetes %>%
mutate_all(~ ifelse(is.na(.), median(., na.rm = TRUE), .))
diabetes_mean <- diabetes %>%
mutate_all(~ ifelse(is.na(.), mean(., na.rm = TRUE), .))
fill_mode <- function(x) {
mode_val <- names(sort(table(x), decreasing = TRUE))[1]
x[is.na(x)] <- mode_val
return(x)
}
diabetes_mode <- diabetes %>%
mutate_all(fill_mode)
diabetes_z <- (diabetes - colMeans(diabetes)) / apply(diabetes, 2, sd)
diabetes_z
melted_diabetes <- gather(diabetes_z, key = "Variable", value = "Z-score")
# Vẽ scatter plot cho tất cả các cột
ggplot(melted_diabetes, aes(x = Variable, y = `Z-score`, color = `Z-score`)) +
geom_point() +
labs(x = "Variable", y = "Z-score", title = "Scatter Plots of Z-scores") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Điều chỉnh góc và vị trí của chú thích trên trục x
# Lọc các giá trị Z-score mà tất cả đều nhỏ hơn 700
diabetes_filter <- diabetes[rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z), ]
# Hiển thị kích thước của bộ dữ liệu sau khi loại bỏ
cat("Còn lại số lượng hàng và cột là:", dim(diabetes_filter))
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes_f<-diabetes_filter
<<<<<<< HEAD
=======
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes_f<-diabetes_filter
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes_f<-diabetes_filter
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
#diabetes_f<-diabetes_filter
>>>>>>> bf69e8bd96af1c7edcfcdf92883a59e0f2efff02
diabetes_f $BloodPressure <- NULL
diabetes_f $SkinThickness <- NULL
min_max_scaler <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
diabetes_scale <- as.data.frame(lapply(diabetes_f, min_max_scaler))
diabetes_scale
train <- diabetes_scale [1:530,]
test <- diabetes_scale [531:760,]
model <-glm(Outcome ~.,family=binomial(link='logit'),data=train)
summary(model)
anova(model, test="Chisq")
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
<<<<<<< HEAD
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
=======
#install.packages("corrgram")
library(corrgram)
corrgram(df)
library(caret)
install.packages("caret")
library(caret)
#install.packages("caret")
library(caret)
set.seed(1)
split <- createDataPartition(df$Outcome,p = 0.75,list = FALSE)
head(dfTrain)
#install.packages("corrgram")
library(corrgram)
#install.packages("corrgram")
library(corrgram)
corrgram(diabetes)
set.seed(1)
split <- createDataPartition(diabetes$Outcome,p = 0.75,list = FALSE)
dfTrain <- diabetes[split,]
dfTest <- diabetes[-split,]
#install.packages("caret")
library(caret)
set.seed(1)
split <- createDataPartition(diabetes$Outcome,p = 0.75,list = FALSE)
dfTrain <- diabetes[split,]
dfTest <- diabetes[-split,]
head(dfTrain)
head(dfTest)
# Dùng ma trận nhầm lẫn
accuracy <- function() {
predictions <- predict(model, newdata = dfTest, type = "class")
# So sánh giữa giá trị dự đoán và giá trị thực tế
confusion_matrix <- table(predictions, dfTest$Outcome)
print(confusion_matrix)
# Tính toán độ chính xác từ ma trận nhầm lẫn
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
return (accuracy)
}
# Tính entropy cho từng cột trong dfTrain
# Hàm tính entropy
calculate_entropy <- function(attribute_vector) {
total_count <- length(attribute_vector)
values <- table(attribute_vector)
probabilities <- values / total_count
entropy <- -sum(probabilities * log2(probabilities))
return(entropy)
}
calculate_entropy_for_columns <- function(data) {
entropy_values <- numeric()
for (col in names(data)) {
entropy <- calculate_entropy(data[[col]])
entropy_values <- c(entropy_values, entropy)
}
names(entropy_values) <- names(data)
return(entropy_values)
}
# Tính entropy cho các cột trong dfTrain
entropy_values <- calculate_entropy_for_columns(dfTrain)
entropy_values
# Huấn luyện mô hình cây quyết định
library(rpart)
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + Insulin + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
# In cây quyết định
print(model)
# Biểu đồ cây quyết định
library(rpart.plot)
corrgram(diabetes_filter)
set.seed(1)
split <- createDataPartition(diabetes_filter$Outcome,p = 0.75,list = FALSE)
dfTrain <- diabetes_filter[split,]
dfTest <- diabetes_filter[-split,]
head(dfTrain)
head(dfTest)
# Dùng ma trận nhầm lẫn
accuracy <- function() {
predictions <- predict(model, newdata = dfTest, type = "class")
# So sánh giữa giá trị dự đoán và giá trị thực tế
confusion_matrix <- table(predictions, dfTest$Outcome)
print(confusion_matrix)
# Tính toán độ chính xác từ ma trận nhầm lẫn
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
return (accuracy)
}
# Tính entropy cho từng cột trong dfTrain
# Hàm tính entropy
calculate_entropy <- function(attribute_vector) {
total_count <- length(attribute_vector)
values <- table(attribute_vector)
probabilities <- values / total_count
entropy <- -sum(probabilities * log2(probabilities))
return(entropy)
}
calculate_entropy_for_columns <- function(data) {
entropy_values <- numeric()
for (col in names(data)) {
entropy <- calculate_entropy(data[[col]])
entropy_values <- c(entropy_values, entropy)
}
names(entropy_values) <- names(data)
return(entropy_values)
}
# Tính entropy cho các cột trong dfTrain
entropy_values <- calculate_entropy_for_columns(dfTrain)
entropy_values
# Tính entropy cho từng cột trong dfTrain
# Hàm tính entropy
calculate_entropy <- function(attribute_vector) {
total_count <- length(attribute_vector)
values <- table(attribute_vector)
probabilities <- values / total_count
entropy <- -sum(probabilities * log2(probabilities))
return(entropy)
}
calculate_entropy_for_columns <- function(data) {
entropy_values <- numeric()
for (col in names(data)) {
entropy <- calculate_entropy(data[[col]])
entropy_values <- c(entropy_values, entropy)
}
names(entropy_values) <- names(data)
return(entropy_values)
}
# Tính entropy cho các cột trong dfTrain
entropy_values <- calculate_entropy_for_columns(dfTrain)
entropy_values
# Huấn luyện mô hình cây quyết định
library(rpart)
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + Insulin + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
# In cây quyết định
print(model)
# Biểu đồ cây quyết định
library(rpart.plot)
install.packages("rpart.plot")
# Huấn luyện mô hình cây quyết định
library(rpart)
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + Insulin + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
# In cây quyết định
print(model)
# Biểu đồ cây quyết định
#install.packages("rpart.plot")
library(rpart.plot)
rpart.plot(model)
library(vip)
install.packages("vip")
#install.packages("vip")
library(vip)
var_importance <- vip::vip(model, num_features = 10)
print(var_importance)
library(pdp)
install.packages("pdp")
#install.packages("pdp")
library(pdp)
library(ggplot2)
# Lặp qua từng cột trong dfTrain (loại bỏ cột mục tiêu)
for (col in names(dfTrain)[-ncol(dfTrain)]) {
# Tạo Partial Dependence Plot cho từng cột và lưu vào biến pdp_plot
pdp_plot <- partial(model, pred.var = col)
# Tạo biểu đồ Partial Dependence Plot và hiển thị
plot(pdp_plot, main = paste("Partial Dependence Plot for", col))
}
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
model <- rpart(Outcome ~ Glucose + BloodPressure + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
accuracy()
rules <- rpart.rules(model)
print(rules)
library(ggplot2)
diabetes_filter$BMI_Category <- cut(diabetes_filter$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c("Underweight", "Normal", "Overweight", "Obese"))
ggplot(diabetes_filter, aes(x = BMI_Category)) +
geom_bar(stat = "count") +
labs(title = "Distribution of BMI Categories", x = "BMI Category", y = "Count") +
theme_bw()
num_diabetes <- diabetes_filter
num_diabetes$BMI_Category <- cut(diabetes_filter$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c(0, 1, 2, 3))
num_diabetes$BMI_Category <- as.integer(num_diabetes$BMI_Category)
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(num_diabetes),2)
# reduce the size of correlation matrix
melted_corr_mat <- melt(corr_mat)
# head(melted_corr_mat)
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + geom_tile() +
geom_text(aes(Var2, Var1, label = value), color = "white", size = 4)
set.seed(12)
samp <- sample(nrow(diabetes_filter), 0.5 * nrow(diabetes_filter))
train <- diabetes_filter[samp, ]
test <- diabetes_filter[-samp, ]
#Kiểm tra kích thước của tập dữ liệu huấn luyện và kiểm tra
dim(train)
library(randomForest)
install.packages("randomForest")
#install.packages("randomForest")
library(randomForest)
ggplot2::margin()
#install.packages("randomForest")
library(randomForest)
rf_fit <- tuneRF(
x = train[,-9],
y = train$BMI_Category,
metric = "OOBAcc",
ntreeTry = 100,
mtryStart = 3,
stepFactor = 1.5,
improve = 0.01,
trace = T,
plot = T
)
# Lặp lại quá trình huấn luyện và đánh giá trên các giá trị khác nhau của ntree
error_out_of_bag <- c()
error_test <- c()
for (ntree in 1:100) {
# Huấn luyện mô hình
model <- randomForest(BMI_Category ~ . -DiabetesPedigreeFunction -Age -Outcome -Pregnancies, data = train, ntree = ntree, mtry=3)
# Tính lỗi ra ngoài túi
error_out_of_bag[ntree] <- mean(predict(model, train) != train$BMI_Category)
# Tính lỗi kiểm tra
error_test[ntree] <- mean(predict(model, test) != test$BMI_Category)
}
# Vẽ đường cong lỗi
plot(error_out_of_bag, type = "l", col = "blue", ylab = "OOB error", xlab="Số cây trong rừng")
lines(error_test, type = "l", col = "red")
model <- randomForest(BMI_Category ~ . -DiabetesPedigreeFunction -Age -Outcome -Pregnancies, data = train, ntree = 100, mtry=3)
model
prediction <- predict(model, newdata = test)
table(prediction, test$BMI_Category)
results<-cbind(prediction,test$BMI_Category)
results
colnames(results)<-c('pred','real')
results<-as.data.frame(results)
View(results)
accuracy <- mean(prediction == test$BMI_Category)
accuracy
library(caret)
model_cv <- train(BMI_Category ~ . -DiabetesPedigreeFunction -Age -Outcome, data = train, method = "rf", metric = "Accuracy", trControl = trainControl(method = "cv", number = 20, search = "grid"))
pred <- predict(model_cv, newdata=test)
table(pred, test$BMI_Category)
accuracy <- mean(pred == test$BMI_Category)
accuracy
<<<<<<< HEAD
# Vẽ biểu đồ histogram
ggplot(diabetes, aes(x = BMI)) +
geom_histogram(binwidth = 2, fill = "lightblue", color = "black") +
labs(x = "BMI", title = "Histogram of BMI") + theme_minimal()
# summary statistics
kable(summary(select(diabetes, BMI)), format = "markdown")
t.test(diabetes$BMI, mu=31)
# Vẽ biểu đồ histogram
ggplot(diabetes, aes(x = BMI_Category)) +
geom_bar(stat = "count") +
labs(title = "Distribution of BMI Categories", x = "BMI Category", y = "Count") +
theme_bw()
# Vẽ biểu đồ histogram
ggplot(diabetes_filter, aes(x = BMI)) +
geom_histogram(binwidth = 2, fill = "lightblue", color = "black") +
labs(x = "BMI", title = "Histogram of BMI") + theme_minimal()
# summary statistics
kable(summary(select(diabetes_filter, BMI)), format = "markdown")
library(knitr)
# Vẽ biểu đồ histogram
ggplot(diabetes_filter, aes(x = BMI)) +
geom_histogram(binwidth = 2, fill = "lightblue", color = "black") +
labs(x = "BMI", title = "Histogram of BMI") + theme_minimal()
# summary statistics
kable(summary(select(diabetes_filter, BMI)), format = "markdown")
t.test(diabetes_filter$BMI, mu=31)
# Vẽ biểu đồ histogram
=======
>>>>>>> 8d95ba537435b1cb845b61044955bdca8d2e138d
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
library(readr)
library(dplyr)
library(readr)
library(dplyr)
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
library(readr)
library(dplyr)
# Đọc file CSV trực tiếp từ đường link
diabetes <- read.csv("https://drive.google.com/uc?id=15mjrv0LV2T6GWNdAuW-QhXVdtMkQALlh")
# Hiển thị dữ liệu
head(diabetes)
na_count<-colSums(sapply(diabetes,is.na))
na_count
diabetes_median <- diabetes %>%
mutate_all(~ ifelse(is.na(.), median(., na.rm = TRUE), .))
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
library(readr)
library(dplyr)
library(readr)
library(dplyr)
install.packages("vctrs")
library(readr)
library(dplyr)
remove.packages("dplyr")
remove.packages("dplyr")
install.packages("dplyr")
library(readr)
library(dplyr)
remove.packages("vctrs")
install.packages("vctrs")
library(readr)
library(dplyr)
remove.packages("rlang")
install.packages("rlang")
library(rlang)
remove.packages("rlang")
install.packages("rlang")
library(dplyr)
install.packages("vctrs")
library(dplyr)
remove.packages("vctrs")
install.packages("vctrs")
library(dplyr)
packageVersion("vctrs")
install.packages("vctrs")
library(dplyr)
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
# Đọc file CSV trực tiếp từ đường link
diabetes <- read.csv("https://drive.google.com/uc?id=15mjrv0LV2T6GWNdAuW-QhXVdtMkQALlh")
# Hiển thị dữ liệu
head(diabetes)
na_count<-colSums(sapply(diabetes,is.na))
na_count
diabetes_median <- diabetes %>%
mutate_all(~ ifelse(is.na(.), median(., na.rm = TRUE), .))
diabetes_mean <- diabetes %>%
mutate_all(~ ifelse(is.na(.), mean(., na.rm = TRUE), .))
fill_mode <- function(x) {
mode_val <- names(sort(table(x), decreasing = TRUE))[1]
x[is.na(x)] <- mode_val
return(x)
}
diabetes_mode <- diabetes %>%
mutate_all(fill_mode)
diabetes_z <- (diabetes - colMeans(diabetes)) / apply(diabetes, 2, sd)
head(diabetes_z)
melted_diabetes <- gather(diabetes_z, key = "Variable", value = "Z-score")
# Vẽ scatter plot cho tất cả các cột
ggplot(melted_diabetes, aes(x = Variable, y = `Z-score`, color = `Z-score`)) +
geom_point() +
labs(x = "Variable", y = "Z-score", title = "Scatter Plots of Z-scores") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Điều chỉnh góc và vị trí của chú thích trên trục x
# Lọc các giá trị Z-score mà tất cả đều nhỏ hơn 700
diabetes_filter <- diabetes[rowSums(apply(diabetes_z, 2, function(x) abs(x) < 700)) == ncol(diabetes_z), ]
# Hiển thị kích thước của bộ dữ liệu sau khi loại bỏ
cat("Còn lại số lượng hàng và cột là:", dim(diabetes_filter))
attach(diabetes_filter)
par(mfrow=c(2,4))
boxplot(Pregnancies~Outcome, main="No. of Pregnancies vs. Diabetes",
xlab="Outcome", ylab="Pregnancies",col="red")
boxplot(Glucose~Outcome, main="Glucose vs. Diabetes",
xlab="Outcome", ylab="Glucose",col="pink")
boxplot(BloodPressure~Outcome, main="Blood Pressure vs. Diabetes",
xlab="Outcome", ylab="Blood Pressure",col="green")
boxplot(SkinThickness~Outcome, main="Skin Thickness vs. Diabetes",
xlab="Outcome", ylab="Skin Thickness",col="orange")
boxplot(Insulin~Outcome, main="Insulin vs. Diabetes",
xlab="Outcome", ylab="Insulin",col="yellow")
boxplot(BMI~Outcome, main="BMI vs. Diabetes",
xlab="Outcome", ylab="BMI",col="purple")
boxplot(DiabetesPedigreeFunction~Outcome, main="Diabetes Pedigree Function vs. Diabetes", xlab="Outcome", ylab="DiabetesPedigreeFunction",col="lightgreen")
boxplot(Age~Outcome, main="Age vs. Diabetes",
xlab="Outcome", ylab="Age",col="lightblue")
box(which = "outer", lty = "solid")
diabetes_f<-diabetes_filter
diabetes_f $BloodPressure <- NULL
diabetes_f $SkinThickness <- NULL
min_max_scaler <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
diabetes_scale <- as.data.frame(lapply(diabetes_f, min_max_scaler))
head(diabetes_scale)
min_max_scaler <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
diabetes_scale <- as.data.frame(lapply(diabetes_f, min_max_scaler))
head(diabetes_scale)
train <- diabetes_scale [1:530,]
test <- diabetes_scale [531:760,]
model <-glm(Outcome ~.,family=binomial(link='logit'),data=train)
summary(model)
anova(model, test="Chisq")
fitted.results <- predict(model,newdata=test,type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
(conf_matrix_logi<-table(fitted.results, test$Outcome))
>>>>>>> bf69e8bd96af1c7edcfcdf92883a59e0f2efff02
TP <- conf_matrix_logi[2, 2]  # True Positive
TN <- conf_matrix_logi[1, 1]  # True Negative
FP <- conf_matrix_logi[1, 2]  # False Positive
FN <- conf_matrix_logi[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
<<<<<<< HEAD
=======
#install.packages("corrgram")
library(corrgram)
corrgram(diabetes_filter)
library(caret)
set.seed(1)
split <- createDataPartition(df$Outcome,p = 0.75,list = FALSE)
dfTrain <- df[split,]
dfTest <- df[-split,]
head(dfTrain)
head(dfTest)
set.seed(1)
split <- createDataPartition(diabetes_scale$Outcome,p = 0.75,list = FALSE)
dfTrain <- diabetes_scale[split,]
dfTest <- diabetes_scale[-split,]
head(dfTrain)
set.seed(1)
split <- createDataPartition(diabetes_f$Outcome,p = 0.75,list = FALSE)
dfTrain <- diabetes_f[split,]
dfTest <- diabetes_f[-split,]
head(dfTrain)
head(dfTest)
# Dùng ma trận nhầm lẫn
accuracy <- function() {
predictions <- predict(model, newdata = dfTest, type = "class")
# So sánh giữa giá trị dự đoán và giá trị thực tế
confusion_matrix <- table(predictions, dfTest$Outcome)
print(confusion_matrix)
# Tính toán độ chính xác từ ma trận nhầm lẫn
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
return (accuracy)
}
thongso <- function() {
predictions <- predict(model, newdata = dfTest, type = "class")
confusion_matrix <- table(predictions, dfTest$Outcome)
TP <- confusion_matrix[2, 2]  # True Positive
TN <- confusion_matrix[1, 1]  # True Negative
FP <- confusion_matrix[1, 2]  # False Positive
FN <- confusion_matrix[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
}
# Huấn luyện mô hình cây quyết định
library(rpart)
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + Insulin + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
set.seed(1)
split <- createDataPartition(diabetes_filter$Outcome,p = 0.75,list = FALSE)
dfTrain <- diabetes_filter[split,]
dfTest <- diabetes_filter[-split,]
head(dfTrain)
head(dfTest)
# Dùng ma trận nhầm lẫn
accuracy <- function() {
predictions <- predict(model, newdata = dfTest, type = "class")
# So sánh giữa giá trị dự đoán và giá trị thực tế
confusion_matrix <- table(predictions, dfTest$Outcome)
print(confusion_matrix)
# Tính toán độ chính xác từ ma trận nhầm lẫn
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
return (accuracy)
}
thongso <- function() {
predictions <- predict(model, newdata = dfTest, type = "class")
confusion_matrix <- table(predictions, dfTest$Outcome)
TP <- confusion_matrix[2, 2]  # True Positive
TN <- confusion_matrix[1, 1]  # True Negative
FP <- confusion_matrix[1, 2]  # False Positive
FN <- confusion_matrix[2, 1]  # False Negative
Accuracy<-(TP+TN)/(TP+TN+FP+FN)
cat("Độ chính xác:",Accuracy,"\n")
#trong số bệnh nhân thực tế bị bệnh tiểu đường,bao nhiêu phần trăm được dự báo bị bệnh
Sensitivity<-TP/(TP+FN)
cat("Độ nhạy:",Sensitivity,"\n")
#trong số bệnh nhân thực tế không bị bệnh, bao nhiêu phần trăm được dự báo không bị bệnh
Specificity<-TN/(TN+FP)
cat("Độ đặc hiệu",Specificity)
}
# Huấn luyện mô hình cây quyết định
library(rpart)
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + Insulin + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
# In cây quyết định
print(model)
# Biểu đồ cây quyết định
library(rpart.plot)
rpart.plot(model)
thongso()
library(vip)
var_importance <- vip::vip(model, num_features = 10)
print(var_importance)
library(pdp)
library(ggplot2)
# Lặp qua từng cột trong dfTrain (loại bỏ cột mục tiêu)
for (col in names(dfTrain)[-ncol(dfTrain)]) {
# Tạo Partial Dependence Plot cho từng cột và lưu vào biến pdp_plot
pdp_plot <- partial(model, pred.var = col)
# Tạo biểu đồ Partial Dependence Plot và hiển thị
plot(pdp_plot, main = paste("Partial Dependence Plot for", col))
}
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
thongso()
model <- rpart(Outcome ~ Glucose + BloodPressure + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
accuracy()
thongso()
model <- rpart(Outcome ~ Glucose + BloodPressure + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
# Huấn luyện mô hình cây quyết định
library(rpart)
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + Insulin + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
# In cây quyết định
print(model)
# Biểu đồ cây quyết định
library(rpart.plot)
rpart.plot(model)
thongso()
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
thongso()
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure + SkinThickness + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
thongso()
model <- rpart(Outcome ~ Glucose + BloodPressure + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
rules <- rpart.rules(model)
print(rules)
model <- rpart(Outcome ~ Glucose +  BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
accuracy()
thongso()
model <- rpart(Outcome ~ Glucose + BloodPressure + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
accuracy()
thongso()
model <- rpart(Outcome ~  Glucose + BloodPressure + SkinThickness + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
thongso()
model <- rpart(Outcome ~ Pregnancies + Glucose + BloodPressure  + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
thongso()
model <- rpart(Outcome ~ Pregnancies + Glucose +  BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
accuracy()
thongso()
accuracy()
thongso()
model <- rpart(Outcome ~ Glucose + BloodPressure + BMI + DiabetesPedigreeFunction + Age, data = dfTrain, method = "class")
rpart.plot(model)
accuracy()
thongso()
rules <- rpart.rules(model)
print(rules)
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(num_diabetes),2)
library(ggplot2)
diabetes_filter$BMI_Category <- cut(diabetes_filter$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c("Underweight", "Normal", "Overweight", "Obese"))
>>>>>>> 3de0a0e5fbe2938e07ea60d1c410ac0b0b394639
ggplot(diabetes_filter, aes(x = BMI_Category)) +
geom_bar(stat = "count") +
labs(title = "Distribution of BMI Categories", x = "BMI Category", y = "Count") +
theme_bw()
<<<<<<< HEAD
#lấy ra những người bệnh và không bệnh có chỉ số BMI_Category >= 3
sick <- diabetes_filter[diabetes_filter$Outcome==1 & diabetes_filter$BMI_Category >= 3,10]
normal <- diabetes_filter[diabetes_filter$Outcome==0 & diabetes_filter$BMI_Category >= 3,10]
t.test(normal,sick,var.equal=FALSE)
#lấy ra những người bệnh và không bệnh có chỉ số BMI_Category >= 3
sick <- num_diabetes[num_diabetes$Outcome==1 & num_diabetes$BMI_Category >= 3,10]
normal <- num_diabetes[num_diabetes$Outcome==0 & num_diabetes$BMI_Category >= 3,10]
t.test(normal,sick,var.equal=FALSE)
#lấy ra những người bệnh và không bệnh có chỉ số BMI_Category >= 3
sick <- num_diabetes[num_diabetes$Outcome==1 & num_diabetes$BMI_Category >= 3,10]
normal <- num_diabetes[num_diabetes$Outcome==0 & num_diabetes$BMI_Category >= 3,10]
num_diabetes
t.test(normal,sick,var.equal=FALSE)
#lấy ra những người bệnh và không bệnh có chỉ số BMI_Category >= 3
sick <- num_diabetes[num_diabetes$Outcome==1 & num_diabetes$BMI_Category >= 3,10]
normal <- num_diabetes[num_diabetes$Outcome==0 & num_diabetes$BMI_Category >= 3,10]
num_diabetes
diabetes_filter
t.test(normal,sick,var.equal=FALSE)
#lấy ra những người bệnh và không bệnh có chỉ số BMI_Category >= 3
sick <- diabetes_filter[diabetes_filter$Outcome==1 & diabetes_filter$BMI_Category >= 3,10]
normal <- diabetes_filter[diabetes_filter$Outcome==0 & diabetes_filter$BMI_Category >= 3,10]
num_diabetes
diabetes_filter
t.test(normal,sick,var.equal=FALSE)
=======
>>>>>>> 3de0a0e5fbe2938e07ea60d1c410ac0b0b394639
num_diabetes <- diabetes_filter
num_diabetes$BMI_Category <- cut(diabetes_filter$BMI,
breaks = c(-Inf, 18.5, 24.9, 29.9, Inf),
labels = c(0, 1, 2, 3))
num_diabetes$BMI_Category <- as.integer(num_diabetes$BMI_Category)
<<<<<<< HEAD
num_diabetes
#lấy ra những người bệnh và không bệnh có chỉ số BMI_Category >= 3
sick <- num_diabetes[num_diabetes$Outcome==1 & num_diabetes$BMI_Category >= 3,10]
normal <- num_diabetes[num_diabetes$Outcome==0 & num_diabetes$BMI_Category >= 3,10]
t.test(normal,sick,var.equal=FALSE)
t.test(diabetes$Age, mu=32)
knitr::opts_chunk$set(echo = TRUE)
install.packages("cowplot")
install.packages("gridExtra")
=======
library(lattice)
library(reshape2)
# creating correlation matrix
corr_mat <- round(cor(num_diabetes),2)
# reduce the size of correlation matrix
melted_corr_mat <- melt(corr_mat)
# head(melted_corr_mat)
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + geom_tile() +
geom_text(aes(Var2, Var1, label = value), color = "white", size = 4)
set.seed(12)
samp <- sample(nrow(diabetes_filter), 0.5 * nrow(diabetes_filter))
train <- diabetes_filter[samp, ]
test <- diabetes_filter[-samp, ]
#Kiểm tra kích thước của tập dữ liệu huấn luyện và kiểm tra
dim(train)
#install.packages("randomForest")
library(randomForest)
install.packages("randomForest")
library(randomForest)
rf_fit <- tuneRF(
x = train[,-9],
y = train$BMI_Category,
metric = "OOBAcc",
ntreeTry = 100,
mtryStart = 3,
stepFactor = 1.5,
improve = 0.01,
trace = T,
plot = T
)
# Lặp lại quá trình huấn luyện và đánh giá trên các giá trị khác nhau của ntree
error_out_of_bag <- c()
error_test <- c()
for (ntree in 1:100) {
# Huấn luyện mô hình
model <- randomForest(BMI_Category ~ . -DiabetesPedigreeFunction -Age -Outcome -Pregnancies, data = train, ntree = ntree, mtry=3)
# Tính lỗi ra ngoài túi
error_out_of_bag[ntree] <- mean(predict(model, train) != train$BMI_Category)
# Tính lỗi kiểm tra
error_test[ntree] <- mean(predict(model, test) != test$BMI_Category)
}
# Vẽ đường cong lỗi
plot(error_out_of_bag, type = "l", col = "blue", ylab = "OOB error", xlab="Số cây trong rừng")
lines(error_test, type = "l", col = "red")
model <- randomForest(BMI_Category ~ . -DiabetesPedigreeFunction -Age -Outcome -Pregnancies, data = train, ntree = 100, mtry=3)
model
prediction <- predict(model, newdata = test)
table(prediction, test$BMI_Category)
results<-cbind(prediction,test$BMI_Category)
head(results)
colnames(results)<-c('pred','real')
results<-as.data.frame(results)
View(results)
accuracy <- mean(prediction == test$BMI_Category)
accuracy
library(caret)
model_cv <- train(BMI_Category ~ . -DiabetesPedigreeFunction -Age -Outcome, data = train, method = "rf", metric = "Accuracy", trControl = trainControl(method = "cv", number = 20, search = "grid"))
pred <- predict(model_cv, newdata=test)
table(pred, test$BMI_Category)
accuracy <- mean(pred == test$BMI_Category)
accuracy
library(knitr)
accuracy <- mean(pred == test$BMI_Category)
accuracy
>>>>>>> 3de0a0e5fbe2938e07ea60d1c410ac0b0b394639
>>>>>>> bf69e8bd96af1c7edcfcdf92883a59e0f2efff02
